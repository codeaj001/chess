import { AiModel as AIModel, ChessMatch as Match } from "@shared/schema";
import { enginePersonalities } from "./engines/personalities";

/**
 * Convert engine personalities to AIModel format for the application
 */
export const mockAIModels: AIModel[] = enginePersonalities.map(
	(personality) => {
		return {
			id: personality.id,
			name: personality.name,
			elo: personality.elo,
			style: personality.style,
			opening_preferences: JSON.stringify(
				personality.opening_preferences
			),
			middlegame_strength: Math.ceil(personality.elo / 500), // Scale from 1-5 based on ELO
			endgame_strength: Math.ceil(personality.elo / 500), // Scale from 1-5 based on ELO
			is_premium: personality.elo > 2000, // Premium models are higher rated
			created_at: new Date(),
		};
	}
);

// Mock matches
export const mockMatches: Match[] = [
	{
		id: 1,
		solana_match_id: 1001,
		white_bot_id: 1,
		black_bot_id: 2,
		match_pubkey: null,
		status: "InProgress",
		match_type: "Regular",
		start_time: new Date(Date.now() - 20 * 60 * 1000), // Started 20 minutes ago
		end_time: null,
		result: null,
		bets_locked: false,
		white_pool: 2.5,
		black_pool: 2.0,
		draw_pool: 0.25,
		moves: JSON.stringify([
			"e4",
			"e5",
			"Nf3",
			"Nc6",
			"Bb5",
			"a6",
			"Ba4",
			"Nf6",
			"O-O",
			"Be7",
			"Re1",
			"b5",
			"Bb3",
			"d6",
			"c3",
			"O-O",
			"h3",
			"Na5",
			"Bc2",
			"c5",
			"d4",
			"Qc7",
			"Nbd2",
			"cxd4",
			"cxd4",
			"Nc6",
		]),
		time_control: "10+0",
		created_at: new Date(),
	},
	{
		id: 2,
		solana_match_id: 1002,
		white_bot_id: 3,
		black_bot_id: 4,
		match_pubkey: null,
		status: "Scheduled",
		match_type: "Tournament",
		start_time: new Date(Date.now() + 15 * 60 * 1000), // Starting in 15 minutes
		end_time: null,
		result: null,
		bets_locked: false,
		white_pool: 1.8,
		black_pool: 2.2,
		draw_pool: 0.5,
		moves: null,
		time_control: "5+3",
		created_at: new Date(),
	},
	{
		id: 3,
		solana_match_id: 1003,
		white_bot_id: 2,
		black_bot_id: 3,
		match_pubkey: null,
		status: "Scheduled",
		match_type: "Regular",
		start_time: new Date(Date.now() + 45 * 60 * 1000), // Starting in 45 minutes
		end_time: null,
		result: null,
		bets_locked: false,
		white_pool: 1.0,
		black_pool: 1.5,
		draw_pool: 0.3,
		moves: null,
		time_control: "15+10",
		created_at: new Date(),
	},
];

// Mock bets
export const mockBets = [
	{
		id: "1",
		match_id: 1,
		solana_match_id: 1001,
		user_wallet: "DemoWallet123456",
		amount: 0.5,
		outcome: "White",
		transaction_signature: "MOCK_TX_SIG_12345678",
		timestamp: new Date(Date.now() - 10 * 60 * 1000),
		status: "Active",
		claimed: false,
		payout: null,
	},
	{
		id: "2",
		match_id: 1,
		solana_match_id: 1001,
		user_wallet: "DemoWallet654321",
		amount: 1.0,
		outcome: "Black",
		transaction_signature: "MOCK_TX_SIG_87654321",
		timestamp: new Date(Date.now() - 15 * 60 * 1000),
		status: "Active",
		claimed: false,
		payout: null,
	},
];

import { ChessEngine } from "./chess-engine";
import { Chess } from "chess.js";

/**
 * Helper function to generate a chess move using the real chess engine
 * @param fen FEN string representing the current position
 * @param aiId ID of the AI model to use
 * @returns A move in algebraic notation (e.g. "e4", "Nf3") or null if no move is possible
 */
export async function generateChessMove(
	fen: string,
	aiId: number | null = null
): Promise<string | null> {
	try {
		// If the game is over, return null
		const chess = new Chess(fen);
		if (chess.isGameOver()) {
			return null;
		}

		// Find the AI model
		const aiModel = aiId
			? mockAIModels.find((model) => model.id === aiId)
			: mockAIModels[0];

		if (!aiModel) {
			// Fallback to random move if AI model not found
			console.warn(
				`AI model with ID ${aiId} not found, using random move`
			);
			const legalMoves = chess.moves();
			if (legalMoves.length === 0) return null;
			return legalMoves[Math.floor(Math.random() * legalMoves.length)];
		}

		try {
			// Use our real chess engine to generate a move based on AI style
			console.log(
				`Generating move for AI ${aiModel.id} (${aiModel.name}) at position ${fen}`
			);
			const move = await ChessEngine.generateMove(aiModel, fen);

			// Verify the move is valid
			try {
				const verifyChess = new Chess(fen);
				verifyChess.move(move);
				console.log(`Generated move: ${move}`);
				return move;
			} catch (invalidMoveError) {
				console.error(
					`Invalid move generated by chess engine: ${move}`,
					invalidMoveError
				);
				// Fallback to random move if the generated move is invalid
				const legalMoves = chess.moves();
				if (legalMoves.length === 0) return null;
				const randomMove =
					legalMoves[Math.floor(Math.random() * legalMoves.length)];
				console.log(`Using fallback random move: ${randomMove}`);
				return randomMove;
			}
		} catch (error) {
			console.error(`Error using chess engine for AI ${aiId}:`, error);
			// Fallback to random move if chess engine fails
			const legalMoves = chess.moves();
			if (legalMoves.length === 0) return null;
			const randomMove =
				legalMoves[Math.floor(Math.random() * legalMoves.length)];
			console.log(
				`Using fallback random move after engine error: ${randomMove}`
			);
			return randomMove;
		}
	} catch (error) {
		console.error(`Error generating chess move:`, error);
		// Return a common opening move as a last resort
		try {
			const chess = new Chess();
			const legalMoves = chess.moves();
			if (legalMoves.length > 0) {
				const randomMove =
					legalMoves[Math.floor(Math.random() * legalMoves.length)];
				console.log(`Using last resort random move: ${randomMove}`);
				return randomMove;
			}
		} catch (e) {
			console.error(`Error generating last resort move:`, e);
		}
		console.log(`Using hardcoded move: e4`);
		return "e4";
	}
}
