import { Chess, Move } from "chess.js";
import { AIModel } from "@shared/schema";
import { engineManager } from "./engines/engine-manager";

/**
 * Chess engine that generates moves using Leela Chess Zero with different personalities
 */
export class ChessEngine {
	/**
	 * Generate a move based on the AI model's style and the current position
	 * @param aiModel The AI model to generate a move for
	 * @param fen The FEN string representing the current position
	 * @returns A move in algebraic notation (e.g. "e4", "Nf3")
	 */
	static async generateMove(aiModel: AIModel, fen: string): Promise<string> {
		try {
			// Initialize the engine manager if not already initialized
			if (!engineManager["initialized"]) {
				await engineManager.initialize();
			}

			const chess = new Chess(fen);

			// If the game is over, return null
			if (chess.isGameOver()) {
				return null;
			}

			// Get all legal moves
			const legalMoves = chess.moves({ verbose: true });

			// If no legal moves, return null
			if (legalMoves.length === 0) {
				return null;
			}

			// Use the real chess engine to generate a move
			try {
				console.log(
					`Generating move for AI ${aiModel.id} (${aiModel.name}) at position ${fen}`
				);
				const move = await engineManager.generateMove(fen, aiModel.id);

				// Verify the move is valid
				try {
					const verifyChess = new Chess(fen);
					verifyChess.move(move);
					console.log(`Generated move: ${move}`);
					return move;
				} catch (invalidMoveError) {
					console.error(
						`Invalid move generated by engine: ${move}`,
						invalidMoveError
					);
					// Fall through to fallback move generation
				}
			} catch (error) {
				console.error("Error using real engine:", error);
				// Fall through to fallback move generation
			}

			// Fallback to the original algorithm if the real engine fails
			console.log(
				`Using fallback move generation for AI ${aiModel.id} (${aiModel.name})`
			);
			return this.generateFallbackMove(aiModel, fen);
		} catch (error) {
			console.error("Error in generateMove:", error);

			// Last resort fallback - return a random legal move
			const chess = new Chess(fen);
			const moves = chess.moves();
			if (moves.length === 0) return null;
			return moves[Math.floor(Math.random() * moves.length)];
		}
	}

	/**
	 * Generate a fallback move using the original algorithm
	 * @param aiModel The AI model to generate a move for
	 * @param fen The FEN string representing the current position
	 * @returns A move in algebraic notation (e.g. "e4", "Nf3")
	 */
	private static generateFallbackMove(aiModel: AIModel, fen: string): string {
		const chess = new Chess(fen);

		// If the game is over, return null
		if (chess.isGameOver()) {
			return null;
		}

		// Get all legal moves
		const legalMoves = chess.moves({ verbose: true });

		// If no legal moves, return null
		if (legalMoves.length === 0) {
			return null;
		}

		// Apply different move selection strategies based on AI style
		const style = aiModel.style;
		const elo = aiModel.elo;

		// Determine if we should make a mistake based on ELO
		// Higher ELO = fewer mistakes
		const makeMistake = Math.random() > elo / 3000;

		// If making a mistake, just return a random move
		if (makeMistake) {
			const randomMove =
				legalMoves[Math.floor(Math.random() * legalMoves.length)];
			return randomMove.san;
		}

		// Otherwise, use style-based move selection
		let selectedMove: Move;

		switch (style) {
			case "Aggressive":
				selectedMove = this.selectAggressiveMove(chess, legalMoves);
				break;
			case "Defensive":
				selectedMove = this.selectDefensiveMove(chess, legalMoves);
				break;
			case "Positional":
				selectedMove = this.selectPositionalMove(chess, legalMoves);
				break;
			case "Tactical":
				selectedMove = this.selectTacticalMove(chess, legalMoves);
				break;
			case "Classical":
				selectedMove = this.selectClassicalMove(chess, legalMoves);
				break;
			case "Neural":
				selectedMove = this.selectNeuralMove(chess, legalMoves);
				break;
			default:
				// Mixed style - randomly select a strategy
				const strategies = [
					this.selectAggressiveMove,
					this.selectDefensiveMove,
					this.selectPositionalMove,
					this.selectTacticalMove,
					this.selectClassicalMove,
					this.selectNeuralMove,
				];
				const randomStrategy =
					strategies[Math.floor(Math.random() * strategies.length)];
				selectedMove = randomStrategy(chess, legalMoves);
		}

		return selectedMove.san;
	}

	/**
	 * Select an aggressive move - prioritize captures, checks, and attacks
	 */
	private static selectAggressiveMove(
		chess: Chess,
		legalMoves: Move[]
	): Move {
		// Prioritize: 1. Checkmate 2. Capture high-value pieces 3. Checks 4. Attacks 5. Random move

		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for captures, prioritizing high-value pieces
		const captures = legalMoves.filter((move) => move.flags.includes("c"));
		if (captures.length > 0) {
			// Sort captures by piece value (Q > R > B/N > P)
			const pieceValues: Record<string, number> = {
				q: 9,
				r: 5,
				b: 3,
				n: 3,
				p: 1,
			};
			captures.sort((a, b) => {
				const aValue = pieceValues[a.captured] || 0;
				const bValue = pieceValues[b.captured] || 0;
				return bValue - aValue;
			});

			// 80% chance to take the highest value piece, 20% chance for a random capture
			if (Math.random() < 0.8) {
				return captures[0];
			} else {
				return captures[Math.floor(Math.random() * captures.length)];
			}
		}

		// Look for checks
		const checks = legalMoves.filter((move) => {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			return testChess.isCheck();
		});

		if (checks.length > 0) {
			return checks[Math.floor(Math.random() * checks.length)];
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}

	/**
	 * Select a defensive move - prioritize safety and avoiding captures
	 */
	private static selectDefensiveMove(chess: Chess, legalMoves: Move[]): Move {
		// Prioritize: 1. Checkmate 2. Avoiding captures 3. Castling 4. Developing pieces safely

		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for castling moves
		const castlingMoves = legalMoves.filter(
			(move) => move.flags.includes("k") || move.flags.includes("q")
		);
		if (castlingMoves.length > 0 && Math.random() < 0.8) {
			return castlingMoves[
				Math.floor(Math.random() * castlingMoves.length)
			];
		}

		// Evaluate each move for safety
		const moveScores = legalMoves.map((move) => {
			const testChess = new Chess(chess.fen());
			testChess.move(move);

			// Check if this move would allow a capture on the next move
			const opponentMoves = testChess.moves({ verbose: true });
			const opponentCaptures = opponentMoves.filter((m) =>
				m.flags.includes("c")
			);

			// Score is negative if opponent can capture, weighted by piece value
			let score = 0;
			if (opponentCaptures.length > 0) {
				const pieceValues: Record<string, number> = {
					q: 9,
					r: 5,
					b: 3,
					n: 3,
					p: 1,
					k: 100,
				};
				const worstCapture = opponentCaptures.reduce(
					(worst, current) => {
						const currentValue = pieceValues[current.captured] || 0;
						const worstValue = pieceValues[worst.captured] || 0;
						return currentValue > worstValue ? current : worst;
					},
					opponentCaptures[0]
				);

				score = -(pieceValues[worstCapture.captured] || 0);
			}

			return { move, score };
		});

		// Sort by score (highest first)
		moveScores.sort((a, b) => b.score - a.score);

		// 80% chance to pick the safest move, 20% chance for a random move
		if (Math.random() < 0.8 && moveScores.length > 0) {
			return moveScores[0].move;
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}

	/**
	 * Select a positional move - prioritize control of the center and piece development
	 */
	private static selectPositionalMove(
		chess: Chess,
		legalMoves: Move[]
	): Move {
		// For simplicity, we'll focus on:
		// 1. Center control (e4, d4, e5, d5)
		// 2. Piece development
		// 3. Castling

		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for castling moves
		const castlingMoves = legalMoves.filter(
			(move) => move.flags.includes("k") || move.flags.includes("q")
		);
		if (castlingMoves.length > 0 && Math.random() < 0.7) {
			return castlingMoves[
				Math.floor(Math.random() * castlingMoves.length)
			];
		}

		// Look for center control moves
		const centerSquares = ["e4", "d4", "e5", "d5"];
		const centerMoves = legalMoves.filter((move) =>
			centerSquares.includes(move.to)
		);
		if (centerMoves.length > 0 && Math.random() < 0.6) {
			return centerMoves[Math.floor(Math.random() * centerMoves.length)];
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}

	/**
	 * Select a tactical move - look for forks, pins, and tactical opportunities
	 */
	private static selectTacticalMove(chess: Chess, legalMoves: Move[]): Move {
		// This is a simplified version - a real tactical engine would be much more complex

		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for checks that also attack a piece (potential fork)
		const potentialForks = legalMoves.filter((move) => {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			return testChess.isCheck();
		});

		if (potentialForks.length > 0 && Math.random() < 0.7) {
			return potentialForks[
				Math.floor(Math.random() * potentialForks.length)
			];
		}

		// Look for captures
		const captures = legalMoves.filter((move) => move.flags.includes("c"));
		if (captures.length > 0 && Math.random() < 0.6) {
			return captures[Math.floor(Math.random() * captures.length)];
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}

	/**
	 * Select a classical move - balanced approach with emphasis on development and structure
	 */
	private static selectClassicalMove(chess: Chess, legalMoves: Move[]): Move {
		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for castling moves
		const castlingMoves = legalMoves.filter(
			(move) => move.san === "O-O" || move.san === "O-O-O"
		);
		if (castlingMoves.length > 0 && Math.random() < 0.7) {
			return castlingMoves[
				Math.floor(Math.random() * castlingMoves.length)
			];
		}

		// Look for center control moves
		const centerSquares = ["e4", "d4", "e5", "d5"];
		const centerMoves = legalMoves.filter((move) =>
			centerSquares.includes(move.to)
		);
		if (centerMoves.length > 0 && Math.random() < 0.6) {
			return centerMoves[Math.floor(Math.random() * centerMoves.length)];
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}

	/**
	 * Select a neural-network-like move - sometimes brilliant, sometimes surprising
	 */
	private static selectNeuralMove(chess: Chess, legalMoves: Move[]): Move {
		// Neural networks sometimes make "surprising" moves
		// We'll simulate this by occasionally making a completely random move
		// and otherwise using a mix of strategies

		if (Math.random() < 0.2) {
			// Completely random move to simulate "surprising" neural network behavior
			return legalMoves[Math.floor(Math.random() * legalMoves.length)];
		}

		// Look for checkmate
		for (const move of legalMoves) {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			if (testChess.isCheckmate()) {
				return move;
			}
		}

		// Look for checks
		const checks = legalMoves.filter((move) => {
			const testChess = new Chess(chess.fen());
			testChess.move(move);
			return testChess.isCheck();
		});

		if (checks.length > 0 && Math.random() < 0.7) {
			return checks[Math.floor(Math.random() * checks.length)];
		}

		// Look for captures
		const captures = legalMoves.filter((move) => move.flags.includes("c"));
		if (captures.length > 0 && Math.random() < 0.6) {
			return captures[Math.floor(Math.random() * captures.length)];
		}

		// Default to a random move
		return legalMoves[Math.floor(Math.random() * legalMoves.length)];
	}
}
